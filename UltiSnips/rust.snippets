snippet le "Declare a variable"
let ${1:name} = ${2:value}
endsnippet

snippet lem "Declare a variable"
let mut ${1:name} = ${2:value}
endsnippet

snippet permutation "next permutation"
pub trait LexicalPermutation {
    /// Return  if the slice was permuted,  if it is already
    /// at the last ordered permutation.
    fn next_permutation(&mut self) -> bool;
    /// Return  if the slice was permuted,  if it is already
    /// at the first ordered permutation.
    fn prev_permutation(&mut self) -> bool;
}

impl<T> LexicalPermutation for [T]
where
    T: Ord,
{
    /// Original author in Rust: Thomas Backman <serenity@exscape.org>
    fn next_permutation(&mut self) -> bool {
        // These cases only have 1 permutation each, so we can't do anything.
        if self.len() < 2 {
            return false;
        }

        // Step 1: Identify the longest, rightmost weakly decreasing part of the vector
        let mut i = self.len() - 1;
        while i > 0 && self[i - 1] >= self[i] {
            i -= 1;
        }

        // If that is the entire vector, this is the last-ordered permutation.
        if i == 0 {
            return false;
        }

        // Step 2: Find the rightmost element larger than the pivot (i-1)
        let mut j = self.len() - 1;
        while j >= i && self[j] <= self[i - 1] {
            j -= 1;
        }

        // Step 3: Swap that element with the pivot
        self.swap(j, i - 1);

        // Step 4: Reverse the (previously) weakly decreasing part
        self[i..].reverse();

        true
    }

    fn prev_permutation(&mut self) -> bool {
        // These cases only have 1 permutation each, so we can't do anything.
        if self.len() < 2 {
            return false;
        }

        // Step 1: Identify the longest, rightmost weakly increasing part of the vector
        let mut i = self.len() - 1;
        while i > 0 && self[i - 1] <= self[i] {
            i -= 1;
        }

        // If that is the entire vector, this is the first-ordered permutation.
        if i == 0 {
            return false;
        }

        // Step 2: Reverse the weakly increasing part
        self[i..].reverse();

        // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)
        let mut j = self.len() - 1;
        while j >= i && self[j - 1] < self[i - 1] {
            j -= 1;
        }

        // Step 4: Swap that element with the pivot
        self.swap(i - 1, j);

        true
    }
}
endsnippet

snippet converte_char_num "Converte char to num"
let num: i32 = c as i32 - 48;
endsnippet

snippet LCM "最小公倍数" 
fn lcm(a: i32, b: i32) -> i32 {
    let mut a = a;
    let mut b = b;

    let x = a * b;

    if a > b {
        let tmp = a;
        a = b;
        b = tmp;
    }

    let mut r = a % b;

    while r != 0 {
        a = b;
        b = r;
        r = a % b;
    }

    return x / b;
}
endsnippet

snippet GDG "最大公約数" 
fn gdg(a: i32, b: i32) -> i32 {
    let mut a = a;
    let mut b = b;

    if a > b {
        let tmp = a;
        a = b;
        b = tmp;
    }

    let mut r = a % b;

    while r != 0 {
        a = b;
        b = r;
        r = a % b;
    }

    return b;
}
endsnippet
